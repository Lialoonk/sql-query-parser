/// Whitespace characters including spaces, tabs, newlines, and comments
WHITESPACE  = _{ " " | "\t" | NEWLINE | COMMENT }

/// Newline characters (Unix and Windows style)
NEWLINE     = _{ "\r\n" | "\n" }

/// SQL comments starting with --
COMMENT     = _{ "--" ~ (!NEWLINE ~ ANY)* }

/// Root rule for SQL parsing - starts and ends with input boundaries
sql         = { SOI ~ statement ~ EOI }

/// SQL statement types (SELECT, INSERT, UPDATE, DELETE)
statement   = { (compound_select | insert_stmt | update_stmt | delete_stmt) ~ ";"? }

/// Compound SELECT with UNION support
compound_select = { select_stmt ~ (union_clause)* }

/// UNION clause for combining SELECT statements
union_clause = { UNION_KEY ~ ALL_KEY? ~ select_stmt }

/// SELECT statement with optional FROM, JOIN, and WHERE clauses
select_stmt = { SELECT_KEY ~ projection ~ (FROM_KEY ~ from_item ~ join_clause?)? ~ where_clause? }

/// INSERT statement
insert_stmt = { "INSERT" ~ "INTO" ~ identifier ~ "VALUES" ~ "(" ~ expr ~ ")" }

/// UPDATE statement with optional WHERE clause
update_stmt = { UPDATE_KEY ~ identifier ~ SET_KEY ~ set_list ~ where_clause? }

/// DELETE statement with optional WHERE clause
delete_stmt = { DELETE_KEY ~ FROM_KEY ~ identifier ~ where_clause? }

/// List of columns in parentheses
column_list = { "(" ~ identifier_list ~ ")" }

/// Multiple rows of values for INSERT statements
value_rows  = { value_row ~ ("," ~ value_row)* }

/// Single row of values
value_row   = { "(" ~ expr_list ~ ")" }

/// List of column assignments for UPDATE statements
set_list    = { set_item ~ ("," ~ set_item)* }

/// Single column assignment (column = value)
set_item    = { identifier ~ "=" ~ expr }

/// DISTINCT keyword
distinct    = _{ DISTINCT_KEY }

/// SELECT projection (* or column list)
projection  = { "*" | projection_list }

/// List of projected columns/expressions
projection_list = { projection_item ~ ("," ~ projection_item)* }

/// Single projected item with optional alias
projection_item = { expr ~ (AS_KEY ~ alias)? }

/// FROM clause item (table or subquery)
from_item   = { table_factor }

/// Table reference with optional alias
table_factor = { identifier ~ (AS_KEY? ~ alias_identifier)? | "(" ~ compound_select ~ ")" ~ (AS_KEY? ~ alias_identifier)? }

/// JOIN clause with ON condition
join_clause = { "JOIN" ~ table_factor ~ "ON" ~ expr }

/// WHERE clause with boolean expression
where_clause = { WHERE_KEY ~ expr }

/// GROUP BY clause
group_by_clause = { GROUP_KEY ~ BY_KEY ~ identifier_list }

/// HAVING clause with boolean expression
having_clause = { HAVING_KEY ~ expr }

/// ORDER BY clause
order_by_clause = { ORDER_KEY ~ BY_KEY ~ order_list }

/// LIMIT clause with number
limit_clause = { LIMIT_KEY ~ number }

/// List of ordering expressions
order_list  = { order_item ~ ("," ~ order_item)* }

/// Single ordering expression with optional direction
order_item  = { expr ~ (ASC_KEY | DESC_KEY)? }

/// List of identifiers separated by commas
identifier_list = { identifier ~ ("," ~ identifier)* }

/// List of expressions separated by commas
expr_list   = { expr ~ ("," ~ expr)* }

/// Root expression rule
expr        = { or_expr }

/// OR expression (left-associative)
or_expr     = { and_expr ~ (OR_KEY ~ and_expr)* }

/// AND expression (left-associative)
and_expr    = { not_expr ~ (AND_KEY ~ not_expr)* }

/// NOT expression (optional NOT prefix)
not_expr    = { NOT_KEY? ~ comparison }

/// Comparison expression with optional comparison operators
comparison  = { addition ~ comparison_suffix* }

/// Comparison operators and special constructs (BETWEEN, IN, IS NULL)
comparison_suffix = {
    comp_op ~ addition
  | (NOT_KEY? ~ BETWEEN_KEY ~ addition ~ AND_KEY ~ addition)
  | (NOT_KEY? ~ IN_KEY ~ "(" ~ in_rhs ~ ")")
  | (IS_KEY ~ NOT_KEY? ~ NULL_KEY)
}

/// Right-hand side of IN operator (subquery or expression list)
in_rhs      = { compound_select | expr_list }

/// Comparison operators (=, <>, !=, <=, >=, <, >, LIKE, NOT LIKE)
comp_op     = { "=" | "<>" | "!=" | "<=" | ">=" | "<" | ">" | LIKE_KEY | NOT_KEY ~ LIKE_KEY }

/// Addition and subtraction (left-associative)
addition    = { multiplication ~ (("+" | "-") ~ multiplication)* }

/// Multiplication and division (left-associative)
multiplication = { unary ~ (("*" | "/") ~ unary)* }

/// Unary plus/minus operators
unary       = { ("+" | "-" )* ~ primary }

/// Primary expression elements (literals, functions, columns, subexpressions)
primary     = { literal | function_call | column | "(" ~ expr ~ ")" }

/// Function call with optional arguments
function_call = { identifier ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

/// Column reference (table.column or just column)
column      = @{ identifier ~ ("." ~ identifier)? }

/// Literal values (numbers, strings, NULL, booleans)
literal     = { number | string | NULL_KEY | boolean }

/// Boolean literals (TRUE, FALSE)
boolean     = { TRUE_KEY | FALSE_KEY }

/// Numeric literals with optional decimal part
number      = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

/// String literals in single quotes with escape sequences
string      = @{ "'" ~ (("\\'" | "\\\\" | !"'" ~ ANY))* ~ "'" }

/// Table or column alias
alias       = @{ alias_identifier }

/// Alias identifier (cannot be reserved keyword)
alias_identifier = @{ !RESERVED_KEYWORD ~ identifier }

/// General identifier (letters, digits, underscore, dollar sign)
identifier  = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "$")* }

/// Reserved SQL keywords that cannot be used as identifiers
RESERVED_KEYWORD = _{
    SELECT_KEY | FROM_KEY | WHERE_KEY | GROUP_KEY | BY_KEY | HAVING_KEY | ORDER_KEY | LIMIT_KEY |
    AS_KEY | JOIN_KEY | ON_KEY | INSERT_KEY | INTO_KEY | VALUES_KEY | UPDATE_KEY | SET_KEY |
    DELETE_KEY | UNION_KEY | ALL_KEY | DISTINCT_KEY | AND_KEY | OR_KEY | NOT_KEY | LIKE_KEY |
    TRUE_KEY | FALSE_KEY | NULL_KEY
}

/// SQL Keywords (case-insensitive)

/// SELECT keyword
SELECT_KEY   = _{ "SELECT" | "select" }

/// FROM keyword
FROM_KEY     = _{ "FROM" | "from" }

/// WHERE keyword
WHERE_KEY    = _{ "WHERE" | "where" }

/// GROUP keyword
GROUP_KEY    = _{ "GROUP" | "group" }

/// BY keyword
BY_KEY       = _{ "BY" | "by" }

/// HAVING keyword
HAVING_KEY   = _{ "HAVING" | "having" }

/// ORDER keyword
ORDER_KEY    = _{ "ORDER" | "order" }

/// LIMIT keyword
LIMIT_KEY    = _{ "LIMIT" | "limit" }

/// AS keyword
AS_KEY       = _{ "AS" | "as" }

/// JOIN keyword
JOIN_KEY     = _{ "JOIN" | "join" }

/// INNER keyword
INNER_KEY    = _{ "INNER" | "inner" }

/// LEFT keyword
LEFT_KEY     = _{ "LEFT" | "left" }

/// RIGHT keyword
RIGHT_KEY    = _{ "RIGHT" | "right" }

/// FULL keyword
FULL_KEY     = _{ "FULL" | "full" }

/// USING keyword
USING_KEY    = _{ "USING" | "using" }

/// ON keyword
ON_KEY       = _{ "ON" | "on" }

/// DISTINCT keyword
DISTINCT_KEY = _{ "DISTINCT" | "distinct" }

/// ASC keyword
ASC_KEY      = _{ "ASC" | "asc" }

/// DESC keyword
DESC_KEY     = _{ "DESC" | "desc" }

/// AND keyword
AND_KEY      = _{ "AND" | "and" }

/// OR keyword
OR_KEY       = _{ "OR" | "or" }

/// NOT keyword
NOT_KEY      = _{ "NOT" | "not" }

/// LIKE keyword
LIKE_KEY     = _{ "LIKE" | "like" }

/// TRUE keyword
TRUE_KEY     = _{ "TRUE" | "true" }

/// FALSE keyword
FALSE_KEY    = _{ "FALSE" | "false" }

/// NULL keyword
NULL_KEY     = _{ "NULL" | "null" }

/// INSERT keyword
INSERT_KEY   = _{ "INSERT" | "insert" }

/// INTO keyword
INTO_KEY     = _{ "INTO" | "into" }

/// VALUES keyword
VALUES_KEY   = _{ "VALUES" | "values" }

/// UPDATE keyword
UPDATE_KEY   = _{ "UPDATE" | "update" }

/// SET keyword
SET_KEY      = _{ "SET" | "set" }

/// DELETE keyword
DELETE_KEY   = _{ "DELETE" | "delete" }

/// UNION keyword
UNION_KEY    = _{ "UNION" | "union" }

/// ALL keyword
ALL_KEY      = _{ "ALL" | "all" }

/// BETWEEN keyword
BETWEEN_KEY  = _{ "BETWEEN" | "between" }

/// IN keyword
IN_KEY       = _{ "IN" | "in" }

/// IS keyword
IS_KEY       = _{ "IS" | "is" }

/// JOIN type keywords (INNER, LEFT [OUTER], RIGHT, FULL)
JOIN_TYPE    = _{ (INNER_KEY | LEFT_KEY ~ (SPACE? ~ OUTER_KEY?)?) | RIGHT_KEY | FULL_KEY }

/// OUTER keyword
OUTER_KEY    = _{ "OUTER" | "outer" }

/// Single space character
SPACE        = _{ " " }